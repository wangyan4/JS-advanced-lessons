<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>
<!-- <script>
    var arr = [];

    function fn() {

        for (var i = 0; i < 10; ++i) {
            (function (j) {
                arr[j] = function () {
                    return j;
                }
            })(i);
        }
        return arr;

    }
    fn();
    console.log(arr[3]());
</script> -->

<script>
    // for (var i = 0; i < 5; i++) {
    //     setTimeout(function () {
    //         console.log(new Date, i);
    //     }, 1000 * i);
    // }

    /* for (var i = 0; i < 5; i++) {
        (function (j) { // j = i
            setTimeout(function () {
                console.log(new Date, j,i);
            }, 1000 * i);
        })(i);
    } */



    // function fn1(){
    //     var x = 1;
    //     function fn2(){
    //         return ++x;
    //     }
    //     return fn2();
    // }
    //  var fn3 = fn1();
    //  fn3();
    //  fn3();
    //  fn3();
    //  fn3();




    // 闭包:函数addNum内部定义的的函数(return 函数名)
    // 与其相关的作用域的变量(start)形成的实体
    // start 会留在内存中不会被释放
    //     
    function addNum(start) {
        return function (step) {
            start += step;
            return start;
        }
    }
    var fn3 = addNum(10);
    console.log(fn3(10));



    var tmp = 100;

    function foo(x) {
        var tmp = 3;
        return function (y) {
            console.log(x + y + (++tmp));
        }
    }
    var fee = foo(2);
    fee(10);
    fee(10);
    fee(10);

    // 闭包所带来的影响
    // 1.可以在外部访问函数内部的局部变量
    // 2.闭包函数让关联作用域(局部变量)不释放，保存在内存当中

    /* function foo() {
        var i = 0;

        function bar() {
            console.log(++i);
        }
        return bar();
    }
    foo();
    foo(); */



   /*  function foo() {
        var i = 0;

        function bar() {
            console.log(++i);
        }
        return bar;
    }
    var a = foo();
    var b = foo();
    a();
    a();
    b(); */




    /* var tmp = 100; //注意：词法作用域,形成的闭包是否包含此行的变量tmp？
    function foo(x) {
        //var tmp = 3; //注意：词法作用域，思考：若屏蔽此行，会输出什么？foo之外的tmp是否为闭包的一部分？
        return function (y) {
            console.log(x + y + (++tmp));
        }
    }
    var fee = foo(2); // fee 形成了一个闭包
    fee(10); //
    fee(10); //
    fee(10); // */



    /* 
        function foo(x) {
            var tmp = 3;
            return function (y) {
                x.count = x.count ? x.count + 1 : 1;
                console.log(x + y + tmp, x.count);
            }
        }
        var age = new Number(2);
        var bar = foo(age); //和相关作用域形成了一个闭包
        bar(10); //输出什么？
        bar(10); //输出什么？
        bar(10); //输出什么？ */


    /* function counter() {
        var n = 0;
        return {
            count: function () {
                return ++n;
            },
            reset: function () {
                n = 0;
                return n;
            }
        }
    }
    var c = counter();
    var d = counter();
    console.log(c.count());
    console.log(d.count());
    console.log(c.reset());
    console.log(c.count());
    console.log(d.count()); */

    /*  //避免多次创建
     function fn() {
         var a;
         return function () {
             return a || (a = document.body.appendChild(document.createElement('div')));
         }
     };
     var f = fn();
     f(); */
</script>

</html>